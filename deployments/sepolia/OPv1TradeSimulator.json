{
  "address": "0x0Acc87b66ba1d1954EB68980296f3e738b0d974E",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "receiver",
              "type": "address"
            },
            {
              "internalType": "contract IERC20",
              "name": "sellToken",
              "type": "address"
            },
            {
              "internalType": "contract IERC20",
              "name": "buyToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "sellAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "buyAmount",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "sellTokenBalance",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "buyTokenBalance",
              "type": "bytes32"
            }
          ],
          "internalType": "struct OPv1TradeSimulator.Trade",
          "name": "trade",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            }
          ],
          "internalType": "struct OPv1Interaction.Data[][3]",
          "name": "interactions",
          "type": "tuple[][3]"
        }
      ],
      "name": "simulateTrade",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "gasUsed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "executedBuyAmount",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "sellTokenDelta",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "buyTokenDelta",
                  "type": "int256"
                }
              ],
              "internalType": "struct OPv1TradeSimulator.BalanceDelta",
              "name": "contractBalance",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "sellTokenDelta",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "buyTokenDelta",
                  "type": "int256"
                }
              ],
              "internalType": "struct OPv1TradeSimulator.BalanceDelta",
              "name": "ownerBalance",
              "type": "tuple"
            }
          ],
          "internalType": "struct OPv1TradeSimulator.Result",
          "name": "result",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x08c3e6e64b140252a34a26846a96ac68c961692d6bf665b49f4e68ce8acecaba",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xD0a0b1131d374f84EEf8d76c607A99Dc71534927",
    "contractAddress": null,
    "transactionIndex": 49,
    "gasUsed": "1046627",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd3f50c442f4235dad91b70261cbe1e13f66e12da2c53964eb69002ecfeca4cdd",
    "transactionHash": "0x08c3e6e64b140252a34a26846a96ac68c961692d6bf665b49f4e68ce8acecaba",
    "logs": [],
    "blockNumber": 6177795,
    "cumulativeGasUsed": "7879722",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "953efb213325dd3792bd80cda98dee96",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sellTokenBalance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"buyTokenBalance\",\"type\":\"bytes32\"}],\"internalType\":\"struct OPv1TradeSimulator.Trade\",\"name\":\"trade\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct OPv1Interaction.Data[][3]\",\"name\":\"interactions\",\"type\":\"tuple[][3]\"}],\"name\":\"simulateTrade\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executedBuyAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"sellTokenDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"buyTokenDelta\",\"type\":\"int256\"}],\"internalType\":\"struct OPv1TradeSimulator.BalanceDelta\",\"name\":\"contractBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"sellTokenDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"buyTokenDelta\",\"type\":\"int256\"}],\"internalType\":\"struct OPv1TradeSimulator.BalanceDelta\",\"name\":\"ownerBalance\",\"type\":\"tuple\"}],\"internalType\":\"struct OPv1TradeSimulator.Result\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Oasis Developers\",\"kind\":\"dev\",\"methods\":{\"simulateTrade((address,address,address,address,uint256,uint256,bytes32,bytes32),(address,uint256,bytes)[][3])\":{\"details\":\"Simulates a user trade. This method can be used to determine whether or not a token is supported as well as getting a rough estimate on how much gas is required to execute the trade given a set of interactions. One notable difference, is the simulation doesn't actually require an order. This makes using this method inaccurate for predicting gas usage for specific trades. However, seeing as computing trade executions is completely independent of external contracts (i.e. it does not depend on the tokens being traded or the interactions being executed) the gas consumption should be off by a predicatable amount.\",\"params\":{\"interactions\":\"A set of interactions to settle the trade against.\",\"trade\":\"The trade to simulate.\"}}},\"stateVariables\":{\"USE_ALL_RECEIVED_BUY_TOKENS\":{\"details\":\"Sentinal value to indicate that the buy amount for the trade's out transfer should use all received buy tokens from the interactions specified for the simulation.\"}},\"title\":\"Oasis Protocol v1 Trade Simulator\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/reader/OPv1TradeSimulator.sol\":\"OPv1TradeSimulator\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"src/contracts/OPv1Settlement.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\npragma abicoder v2;\\n\\nimport \\\"./OPv1VaultRelayer.sol\\\";\\nimport \\\"./interfaces/OPv1Authentication.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IVault.sol\\\";\\nimport \\\"./libraries/OPv1Interaction.sol\\\";\\nimport \\\"./libraries/OPv1Order.sol\\\";\\nimport \\\"./libraries/OPv1Trade.sol\\\";\\nimport \\\"./libraries/OPv1Transfer.sol\\\";\\nimport \\\"./libraries/SafeCast.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./mixins/OPv1Signing.sol\\\";\\nimport \\\"./mixins/ReentrancyGuard.sol\\\";\\nimport \\\"./mixins/StorageAccessible.sol\\\";\\n\\n/// @title Oasis Protocol v1 Settlement Contract\\n/// @author Oasis Developers\\ncontract OPv1Settlement is OPv1Signing, ReentrancyGuard, StorageAccessible {\\n    using OPv1Order for bytes;\\n    using OPv1Transfer for IVault;\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n\\n    /// @dev The authenticator is used to determine who can call the settle function.\\n    /// That is, only authorized solvers have the ability to invoke settlements.\\n    /// Any valid authenticator implements an isSolver method called by the onlySolver\\n    /// modifier below.\\n    OPv1Authentication public immutable authenticator;\\n\\n    /// @dev The Balancer Vault the protocol used for managing user funds.\\n    IVault public immutable vault;\\n\\n    /// @dev The Balancer Vault relayer which can interact on behalf of users.\\n    /// This contract is created during deployment\\n    OPv1VaultRelayer public immutable vaultRelayer;\\n\\n    /// @dev Map each user order by UID to the amount that has been filled so\\n    /// far. If this amount is larger than or equal to the amount traded in the\\n    /// order (amount sold for sell orders, amount bought for buy orders) then\\n    /// the order cannot be traded anymore. If the order is fill or kill, then\\n    /// this value is only used to determine whether the order has already been\\n    /// executed.\\n    mapping(bytes => uint256) public filledAmount;\\n\\n    /// @dev Event emitted for each executed trade.\\n    event Trade(\\n        address indexed owner,\\n        IERC20 sellToken,\\n        IERC20 buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        uint256 feeAmount,\\n        bytes orderUid\\n    );\\n\\n    /// @dev Event emitted for each executed interaction.\\n    ///\\n    /// For gas efficiency, only the interaction calldata selector (first 4\\n    /// bytes) is included in the event. For interactions without calldata or\\n    /// whose calldata is shorter than 4 bytes, the selector will be `0`.\\n    event Interaction(address indexed target, uint256 value, bytes4 selector);\\n\\n    /// @dev Event emitted when a settlement completes\\n    event Settlement(address indexed solver);\\n\\n    /// @dev Event emitted when an order is invalidated.\\n    event OrderInvalidated(address indexed owner, bytes orderUid);\\n\\n    constructor(OPv1Authentication authenticator_, IVault vault_) {\\n        authenticator = authenticator_;\\n        vault = vault_;\\n        vaultRelayer = new OPv1VaultRelayer(vault_);\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {\\n        // NOTE: Include an empty receive function so that the settlement\\n        // contract can receive Ether from contract interactions.\\n    }\\n\\n    /// @dev This modifier is called by settle function to block any non-listed\\n    /// senders from settling batches.\\n    modifier onlySolver() {\\n        require(authenticator.isSolver(msg.sender), \\\"OPv1: not a solver\\\");\\n        _;\\n    }\\n\\n    /// @dev Modifier to ensure that an external function is only callable as a\\n    /// settlement interaction.\\n    modifier onlyInteraction() {\\n        require(address(this) == msg.sender, \\\"OPv1: not an interaction\\\");\\n        _;\\n    }\\n\\n    /// @dev Settle the specified orders at a clearing price. Note that it is\\n    /// the responsibility of the caller to ensure that all OPv1 invariants are\\n    /// upheld for the input settlement, otherwise this call will revert.\\n    /// Namely:\\n    /// - All orders are valid and signed\\n    /// - Accounts have sufficient balance and approval.\\n    /// - Settlement contract has sufficient balance to execute trades. Note\\n    ///   this implies that the accumulated fees held in the contract can also\\n    ///   be used for settlement. This is OK since:\\n    ///   - Solvers need to be authorized\\n    ///   - Misbehaving solvers will be slashed for abusing accumulated fees for\\n    ///     settlement\\n    ///   - Critically, user orders are entirely protected\\n    ///\\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\\n    /// Trades encode tokens as indices into this array.\\n    /// @param clearingPrices An array of clearing prices where the `i`-th price\\n    /// is for the `i`-th token in the [`tokens`] array.\\n    /// @param trades Trades for signed orders.\\n    /// @param interactions Smart contract interactions split into three\\n    /// separate lists to be run before the settlement, during the settlement\\n    /// and after the settlement respectively.\\n    function settle(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        OPv1Trade.Data[] calldata trades,\\n        OPv1Interaction.Data[][3] calldata interactions\\n    ) external nonReentrant onlySolver {\\n        executeInteractions(interactions[0]);\\n\\n        (\\n            OPv1Transfer.Data[] memory inTransfers,\\n            OPv1Transfer.Data[] memory outTransfers\\n        ) = computeTradeExecutions(tokens, clearingPrices, trades);\\n\\n        vaultRelayer.transferFromAccounts(inTransfers);\\n\\n        executeInteractions(interactions[1]);\\n\\n        vault.transferToAccounts(outTransfers);\\n\\n        executeInteractions(interactions[2]);\\n\\n        emit Settlement(msg.sender);\\n    }\\n\\n    /// @dev Settle an order directly against Balancer V2 pools.\\n    ///\\n    /// @param swaps The Balancer V2 swap steps to use for trading.\\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\\n    /// Swaps and the trade encode tokens as indices into this array.\\n    /// @param trade The trade to match directly against Balancer liquidity. The\\n    /// order will always be fully executed, so the trade's `executedAmount`\\n    /// field is used to represent a swap limit amount.\\n    function swap(\\n        IVault.BatchSwapStep[] calldata swaps,\\n        IERC20[] calldata tokens,\\n        OPv1Trade.Data calldata trade\\n    ) external nonReentrant onlySolver {\\n        RecoveredOrder memory recoveredOrder = allocateRecoveredOrder();\\n        OPv1Order.Data memory order = recoveredOrder.data;\\n        recoverOrderFromTrade(recoveredOrder, tokens, trade);\\n\\n        IVault.SwapKind kind = order.kind == OPv1Order.KIND_SELL\\n            ? IVault.SwapKind.GIVEN_IN\\n            : IVault.SwapKind.GIVEN_OUT;\\n\\n        IVault.FundManagement memory funds;\\n        funds.sender = recoveredOrder.owner;\\n        funds.fromInternalBalance =\\n            order.sellTokenBalance == OPv1Order.BALANCE_INTERNAL;\\n        funds.recipient = payable(recoveredOrder.receiver);\\n        funds.toInternalBalance =\\n            order.buyTokenBalance == OPv1Order.BALANCE_INTERNAL;\\n\\n        int256[] memory limits = new int256[](tokens.length);\\n        uint256 limitAmount = trade.executedAmount;\\n        // NOTE: Array allocation initializes elements to 0, so we only need to\\n        // set the limits we care about. This ensures that the swap will respect\\n        // the order's limit price.\\n        if (order.kind == OPv1Order.KIND_SELL) {\\n            require(limitAmount >= order.buyAmount, \\\"OPv1: limit too low\\\");\\n            limits[trade.sellTokenIndex] = order.sellAmount.toInt256();\\n            limits[trade.buyTokenIndex] = -limitAmount.toInt256();\\n        } else {\\n            require(limitAmount <= order.sellAmount, \\\"OPv1: limit too high\\\");\\n            limits[trade.sellTokenIndex] = limitAmount.toInt256();\\n            limits[trade.buyTokenIndex] = -order.buyAmount.toInt256();\\n        }\\n\\n        OPv1Transfer.Data memory feeTransfer;\\n        feeTransfer.account = recoveredOrder.owner;\\n        feeTransfer.token = order.sellToken;\\n        feeTransfer.amount = order.feeAmount;\\n        feeTransfer.balance = order.sellTokenBalance;\\n\\n        int256[] memory tokenDeltas = vaultRelayer.batchSwapWithFee(\\n            kind,\\n            swaps,\\n            tokens,\\n            funds,\\n            limits,\\n            // NOTE: Specify a deadline to ensure that an expire order\\n            // cannot be used to trade.\\n            order.validTo,\\n            feeTransfer\\n        );\\n\\n        bytes memory orderUid = recoveredOrder.uid;\\n        uint256 executedSellAmount = tokenDeltas[trade.sellTokenIndex]\\n            .toUint256();\\n        uint256 executedBuyAmount = (-tokenDeltas[trade.buyTokenIndex])\\n            .toUint256();\\n\\n        // NOTE: Check that the orders were completely filled and update their\\n        // filled amounts to avoid replaying them. The limit price and order\\n        // validity has already been verified when executing the swap through\\n        // the `limit` and `deadline` parameters.\\n        require(filledAmount[orderUid] == 0, \\\"OPv1: order filled\\\");\\n        if (order.kind == OPv1Order.KIND_SELL) {\\n            require(\\n                executedSellAmount == order.sellAmount,\\n                \\\"OPv1: sell amount not respected\\\"\\n            );\\n            filledAmount[orderUid] = order.sellAmount;\\n        } else {\\n            require(\\n                executedBuyAmount == order.buyAmount,\\n                \\\"OPv1: buy amount not respected\\\"\\n            );\\n            filledAmount[orderUid] = order.buyAmount;\\n        }\\n\\n        emit Trade(\\n            recoveredOrder.owner,\\n            order.sellToken,\\n            order.buyToken,\\n            executedSellAmount,\\n            executedBuyAmount,\\n            order.feeAmount,\\n            orderUid\\n        );\\n        emit Settlement(msg.sender);\\n    }\\n\\n    /// @dev Invalidate onchain an order that has been signed offline.\\n    ///\\n    /// @param orderUid The unique identifier of the order that is to be made\\n    /// invalid after calling this function. The user that created the order\\n    /// must be the sender of this message. See [`extractOrderUidParams`]\\n    /// for details on orderUid.\\n    function invalidateOrder(bytes calldata orderUid) external {\\n        (, address owner, ) = orderUid.extractOrderUidParams();\\n        require(owner == msg.sender, \\\"OPv1: caller does not own order\\\");\\n        filledAmount[orderUid] = type(uint256).max;\\n        emit OrderInvalidated(owner, orderUid);\\n    }\\n\\n    /// @dev Free storage from the filled amounts of **expired** orders to claim\\n    /// a gas refund. This method can only be called as an interaction.\\n    ///\\n    /// @param orderUids The unique identifiers of the expired order to free\\n    /// storage for.\\n    function freeFilledAmountStorage(\\n        bytes[] calldata orderUids\\n    ) external onlyInteraction {\\n        freeOrderStorage(filledAmount, orderUids);\\n    }\\n\\n    /// @dev Free storage from the pre signatures of **expired** orders to claim\\n    /// a gas refund. This method can only be called as an interaction.\\n    ///\\n    /// @param orderUids The unique identifiers of the expired order to free\\n    /// storage for.\\n    function freePreSignatureStorage(\\n        bytes[] calldata orderUids\\n    ) external onlyInteraction {\\n        freeOrderStorage(preSignature, orderUids);\\n    }\\n\\n    /// @dev Process all trades one at a time returning the computed net in and\\n    /// out transfers for the trades.\\n    ///\\n    /// This method reverts if processing of any single trade fails. See\\n    /// [`computeTradeExecution`] for more details.\\n    ///\\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\\n    /// @param clearingPrices An array of token clearing prices.\\n    /// @param trades Trades for signed orders.\\n    /// @return inTransfers Array of in transfers of executed sell amounts.\\n    /// @return outTransfers Array of out transfers of executed buy amounts.\\n    function computeTradeExecutions(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        OPv1Trade.Data[] calldata trades\\n    )\\n        internal\\n        returns (\\n            OPv1Transfer.Data[] memory inTransfers,\\n            OPv1Transfer.Data[] memory outTransfers\\n        )\\n    {\\n        RecoveredOrder memory recoveredOrder = allocateRecoveredOrder();\\n\\n        inTransfers = new OPv1Transfer.Data[](trades.length);\\n        outTransfers = new OPv1Transfer.Data[](trades.length);\\n\\n        for (uint256 i; i < trades.length; ++i) {\\n            OPv1Trade.Data calldata trade = trades[i];\\n\\n            recoverOrderFromTrade(recoveredOrder, tokens, trade);\\n            computeTradeExecution(\\n                recoveredOrder,\\n                clearingPrices[trade.sellTokenIndex],\\n                clearingPrices[trade.buyTokenIndex],\\n                trade.executedAmount,\\n                inTransfers[i],\\n                outTransfers[i]\\n            );\\n        }\\n    }\\n\\n    /// @dev Compute the in and out transfer amounts for a single trade.\\n    /// This function reverts if:\\n    /// - The order has expired\\n    /// - The order's limit price is not respected\\n    /// - The order gets over-filled\\n    /// - The fee discount is larger than the executed fee\\n    ///\\n    /// @param recoveredOrder The recovered order to process.\\n    /// @param sellPrice The price of the order's sell token.\\n    /// @param buyPrice The price of the order's buy token.\\n    /// @param executedAmount The portion of the order to execute. This will be\\n    /// ignored for fill-or-kill orders.\\n    /// @param inTransfer Memory location for computed executed sell amount\\n    /// transfer.\\n    /// @param outTransfer Memory location for computed executed buy amount\\n    /// transfer.\\n    function computeTradeExecution(\\n        RecoveredOrder memory recoveredOrder,\\n        uint256 sellPrice,\\n        uint256 buyPrice,\\n        uint256 executedAmount,\\n        OPv1Transfer.Data memory inTransfer,\\n        OPv1Transfer.Data memory outTransfer\\n    ) internal {\\n        OPv1Order.Data memory order = recoveredOrder.data;\\n        bytes memory orderUid = recoveredOrder.uid;\\n\\n        // solhint-disable-next-line not-rely-on-time\\n        require(order.validTo >= block.timestamp, \\\"OPv1: order expired\\\");\\n\\n        // NOTE: The following computation is derived from the equation:\\n        // ```\\n        // amount_x * price_x = amount_y * price_y\\n        // ```\\n        // Intuitively, if a chocolate bar is 0,50\\u20ac and a beer is 4\\u20ac, 1 beer\\n        // is roughly worth 8 chocolate bars (`1 * 4 = 8 * 0.5`). From this\\n        // equation, we can derive:\\n        // - The limit price for selling `x` and buying `y` is respected iff\\n        // ```\\n        // limit_x * price_x >= limit_y * price_y\\n        // ```\\n        // - The executed amount of token `y` given some amount of `x` and\\n        //   clearing prices is:\\n        // ```\\n        // amount_y = amount_x * price_x / price_y\\n        // ```\\n\\n        require(\\n            order.sellAmount.mul(sellPrice) >= order.buyAmount.mul(buyPrice),\\n            \\\"OPv1: limit price not respected\\\"\\n        );\\n\\n        uint256 executedSellAmount;\\n        uint256 executedBuyAmount;\\n        uint256 executedFeeAmount;\\n        uint256 currentFilledAmount;\\n\\n        if (order.kind == OPv1Order.KIND_SELL) {\\n            if (order.partiallyFillable) {\\n                executedSellAmount = executedAmount;\\n                executedFeeAmount = order.feeAmount.mul(executedSellAmount).div(\\n                    order.sellAmount\\n                );\\n            } else {\\n                executedSellAmount = order.sellAmount;\\n                executedFeeAmount = order.feeAmount;\\n            }\\n\\n            executedBuyAmount = executedSellAmount.mul(sellPrice).ceilDiv(\\n                buyPrice\\n            );\\n\\n            currentFilledAmount = filledAmount[orderUid].add(\\n                executedSellAmount\\n            );\\n            require(\\n                currentFilledAmount <= order.sellAmount,\\n                \\\"OPv1: order filled\\\"\\n            );\\n        } else {\\n            if (order.partiallyFillable) {\\n                executedBuyAmount = executedAmount;\\n                executedFeeAmount = order.feeAmount.mul(executedBuyAmount).div(\\n                    order.buyAmount\\n                );\\n            } else {\\n                executedBuyAmount = order.buyAmount;\\n                executedFeeAmount = order.feeAmount;\\n            }\\n\\n            executedSellAmount = executedBuyAmount.mul(buyPrice).div(sellPrice);\\n\\n            currentFilledAmount = filledAmount[orderUid].add(executedBuyAmount);\\n            require(\\n                currentFilledAmount <= order.buyAmount,\\n                \\\"OPv1: order filled\\\"\\n            );\\n        }\\n\\n        executedSellAmount = executedSellAmount.add(executedFeeAmount);\\n        filledAmount[orderUid] = currentFilledAmount;\\n\\n        emit Trade(\\n            recoveredOrder.owner,\\n            order.sellToken,\\n            order.buyToken,\\n            executedSellAmount,\\n            executedBuyAmount,\\n            executedFeeAmount,\\n            orderUid\\n        );\\n\\n        inTransfer.account = recoveredOrder.owner;\\n        inTransfer.token = order.sellToken;\\n        inTransfer.amount = executedSellAmount;\\n        inTransfer.balance = order.sellTokenBalance;\\n\\n        outTransfer.account = recoveredOrder.receiver;\\n        outTransfer.token = order.buyToken;\\n        outTransfer.amount = executedBuyAmount;\\n        outTransfer.balance = order.buyTokenBalance;\\n    }\\n\\n    /// @dev Execute a list of arbitrary contract calls from this contract.\\n    /// @param interactions The list of interactions to execute.\\n    function executeInteractions(\\n        OPv1Interaction.Data[] calldata interactions\\n    ) internal {\\n        for (uint256 i; i < interactions.length; ++i) {\\n            OPv1Interaction.Data calldata interaction = interactions[i];\\n\\n            // To prevent possible attack on user funds, we explicitly disable\\n            // any interactions with the vault relayer contract.\\n            require(\\n                interaction.target != address(vaultRelayer),\\n                \\\"OPv1: forbidden interaction\\\"\\n            );\\n            OPv1Interaction.execute(interaction);\\n\\n            emit Interaction(\\n                interaction.target,\\n                interaction.value,\\n                OPv1Interaction.selector(interaction)\\n            );\\n        }\\n    }\\n\\n    /// @dev Claims refund for the specified storage and order UIDs.\\n    ///\\n    /// This method reverts if any of the orders are still valid.\\n    ///\\n    /// @param orderUids Order refund data for freeing storage.\\n    /// @param orderStorage Order storage mapped on a UID.\\n    function freeOrderStorage(\\n        mapping(bytes => uint256) storage orderStorage,\\n        bytes[] calldata orderUids\\n    ) internal {\\n        for (uint256 i; i < orderUids.length; ++i) {\\n            bytes calldata orderUid = orderUids[i];\\n\\n            (, , uint32 validTo) = orderUid.extractOrderUidParams();\\n            // solhint-disable-next-line not-rely-on-time\\n            require(validTo < block.timestamp, \\\"OPv1: order still valid\\\");\\n\\n            orderStorage[orderUid] = 0;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb53a15609d2bda50678dfc12554c75ee4ca112914eb5b6eb9d70a87f222ad559\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/OPv1VaultRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\npragma abicoder v2;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IVault.sol\\\";\\nimport \\\"./libraries/OPv1Transfer.sol\\\";\\n\\n/// @title Oasis Protocol v1 Vault Relayer Contract\\n/// @author Oasis Developers\\ncontract OPv1VaultRelayer {\\n    using OPv1Transfer for IVault;\\n\\n    /// @dev The creator of the contract which has special permissions. This\\n    /// value is set at creation time and cannot change.\\n    address private immutable creator;\\n\\n    /// @dev The vault this relayer is for.\\n    IVault private immutable vault;\\n\\n    constructor(IVault vault_) {\\n        creator = msg.sender;\\n        vault = vault_;\\n    }\\n\\n    /// @dev Modifier that ensures that a function can only be called by the\\n    /// creator of this contract.\\n    modifier onlyCreator() {\\n        require(msg.sender == creator, \\\"OPv1: not creator\\\");\\n        _;\\n    }\\n\\n    /// @dev Transfers all sell amounts for the executed trades from their\\n    /// owners to the caller.\\n    ///\\n    /// This function reverts if:\\n    /// - The caller is not the creator of the vault relayer\\n    /// - Any ERC20 transfer fails\\n    ///\\n    /// @param transfers The transfers to execute.\\n    function transferFromAccounts(\\n        OPv1Transfer.Data[] calldata transfers\\n    ) external onlyCreator {\\n        vault.transferFromAccounts(transfers, msg.sender);\\n    }\\n\\n    /// @dev Performs a Balancer batched swap on behalf of a user and sends a\\n    /// fee to the caller.\\n    ///\\n    /// This function reverts if:\\n    /// - The caller is not the creator of the vault relayer\\n    /// - The swap fails\\n    /// - The fee transfer fails\\n    ///\\n    /// @param kind The Balancer swap kind, this can either be `GIVEN_IN` for\\n    /// sell orders or `GIVEN_OUT` for buy orders.\\n    /// @param swaps The swaps to perform.\\n    /// @param tokens The tokens for the swaps. Swaps encode to and from tokens\\n    /// as indices into this array.\\n    /// @param funds The fund management settings, specifying the user the swap\\n    /// is being performed for as well as the recipient of the proceeds.\\n    /// @param limits Swap limits for encoding limit prices.\\n    /// @param deadline The deadline for the swap.\\n    /// @param feeTransfer The transfer data for the caller fee.\\n    /// @return tokenDeltas The executed swap amounts.\\n    function batchSwapWithFee(\\n        IVault.SwapKind kind,\\n        IVault.BatchSwapStep[] calldata swaps,\\n        IERC20[] memory tokens,\\n        IVault.FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline,\\n        OPv1Transfer.Data calldata feeTransfer\\n    ) external onlyCreator returns (int256[] memory tokenDeltas) {\\n        tokenDeltas = vault.batchSwap(\\n            kind,\\n            swaps,\\n            tokens,\\n            funds,\\n            limits,\\n            deadline\\n        );\\n        vault.fastTransferFromAccount(feeTransfer, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x71e9d9e5b508f9e8cad212c8400c43c19ff684554289010a9b2ea0b423df1ce8\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin contracts with minor modifications:\\n// - Modified Solidity version\\n// - Formatted code\\n// - Added `name`, `symbol` and `decimals` function declarations\\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol>\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals the token uses.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\",\"keccak256\":\"0x2db02cc0e23db99d10cd21590425b714060a556bcfb934cb5ab3b80aef1610ba\",\"license\":\"MIT\"},\"src/contracts/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.7.6 <0.9.0;\\npragma abicoder v2;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Minimal interface for the Vault core contract only containing methods\\n * used by Oasis Protocol V1. Original source:\\n * <https://github.com/balancer-labs/balancer-core-v2/blob/v1.0.0/contracts/vault/interfaces/IVault.sol>\\n */\\ninterface IVault {\\n    // Internal Balance\\n    //\\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n    //\\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n    // operations of different kinds, with different senders and recipients, at once.\\n\\n    /**\\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n    /**\\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n    struct UserBalanceOp {\\n        UserBalanceOpKind kind;\\n        IERC20 asset;\\n        uint256 amount;\\n        address sender;\\n        address payable recipient;\\n    }\\n\\n    // There are four possible operations in `manageUserBalance`:\\n    //\\n    // - DEPOSIT_INTERNAL\\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n    // relevant for relayers).\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - WITHDRAW_INTERNAL\\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n    // it to the recipient as ETH.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_INTERNAL\\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_EXTERNAL\\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n    // relayers, as it lets them reuse a user's Vault allowance.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `ExternalBalanceTransfer` event.\\n\\n    enum UserBalanceOpKind {\\n        DEPOSIT_INTERNAL,\\n        WITHDRAW_INTERNAL,\\n        TRANSFER_INTERNAL,\\n        TRANSFER_EXTERNAL\\n    }\\n\\n    // Swaps\\n    //\\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n    //\\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n    // individual swaps.\\n    //\\n    // There are two swap kinds:\\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n    //\\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n    // the final intended token.\\n    //\\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n    // much less gas than they would otherwise.\\n    //\\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n    // updating the Pool's internal accounting).\\n    //\\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\\n    //\\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n    //\\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n    //\\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n    enum SwapKind {\\n        GIVEN_IN,\\n        GIVEN_OUT\\n    }\\n\\n    /**\\n     * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IERC20 assetIn;\\n        IERC20 assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IERC20[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n}\\n\",\"keccak256\":\"0x66cd7508d5c23e255792603175d85fb5c035ee9e5b1ec6f37f551a01e55f94ec\",\"license\":\"GPL-3.0-or-later\"},\"src/contracts/interfaces/OPv1Authentication.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title Oasis Protocol v1 Authentication Interface\\n/// @author Oasis Developers\\ninterface OPv1Authentication {\\n    /// @dev determines whether the provided address is an authenticated solver.\\n    /// @param prospectiveSolver the address of prospective solver.\\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\\n    function isSolver(address prospectiveSolver) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x97512e143de46197898f7d1b31ee02bdd0100cdb5d7867a45465acdf96e8b4c3\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/interfaces/OPv1EIP1271.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nlibrary OPv1EIP1271 {\\n    /// @dev Value returned by a call to `isValidSignature` if the signature\\n    /// was verified successfully. The value is defined in EIP-1271 as:\\n    /// bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\\n}\\n\\n/// @title EIP1271 Interface\\n/// @dev Standardized interface for an implementation of smart contract\\n/// signatures as described in EIP-1271. The code that follows is identical to\\n/// the code in the standard with the exception of formatting and syntax\\n/// changes to adapt the code to our Solidity version.\\ninterface EIP1271Verifier {\\n    /// @dev Should return whether the signature provided is valid for the\\n    /// provided data\\n    /// @param _hash      Hash of the data to be signed\\n    /// @param _signature Signature byte array associated with _data\\n    ///\\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\\n    /// solc > 0.5)\\n    /// MUST allow external calls\\n    ///\\n    function isValidSignature(\\n        bytes32 _hash,\\n        bytes memory _signature\\n    ) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0f3de499e4f5ddc3c41d3b72a7170fd3e6390209b88c6a875ba8723927498f40\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/OPv1Interaction.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title Oasis Protocol v1 Interaction Library\\n/// @author Oasis Developers\\nlibrary OPv1Interaction {\\n    /// @dev Interaction data for performing arbitrary contract interactions.\\n    /// Submitted to [`OPv1Settlement.settle`] for code execution.\\n    struct Data {\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    /// @dev Execute an arbitrary contract interaction.\\n    ///\\n    /// @param interaction Interaction data.\\n    function execute(Data calldata interaction) internal {\\n        address target = interaction.target;\\n        uint256 value = interaction.value;\\n        bytes calldata callData = interaction.callData;\\n\\n        // NOTE: Use assembly to call the interaction instead of a low level\\n        // call for two reasons:\\n        // - We don't want to copy the return data, since we discard it for\\n        // interactions.\\n        // - Solidity will under certain conditions generate code to copy input\\n        // calldata twice to memory (the second being a \\\"memcopy loop\\\").\\n        // <https://github.com/gnosis/gp-v2-contracts/pull/417#issuecomment-775091258>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            calldatacopy(freeMemoryPointer, callData.offset, callData.length)\\n            if iszero(\\n                call(\\n                    gas(),\\n                    target,\\n                    value,\\n                    freeMemoryPointer,\\n                    callData.length,\\n                    0,\\n                    0\\n                )\\n            ) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @dev Extracts the Solidity ABI selector for the specified interaction.\\n    ///\\n    /// @param interaction Interaction data.\\n    /// @return result The 4 byte function selector of the call encoded in\\n    /// this interaction.\\n    function selector(\\n        Data calldata interaction\\n    ) internal pure returns (bytes4 result) {\\n        bytes calldata callData = interaction.callData;\\n        if (callData.length >= 4) {\\n            // NOTE: Read the first word of the interaction's calldata. The\\n            // value does not need to be shifted since `bytesN` values are left\\n            // aligned, and the value does not need to be masked since masking\\n            // occurs when the value is accessed and not stored:\\n            // <https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#encoding-of-indexed-event-parameters>\\n            // <https://docs.soliditylang.org/en/v0.7.6/assembly.html#access-to-external-variables-functions-and-libraries>\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                result := calldataload(callData.offset)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8779b5bbbca8afec43be5bbf2dab4bc3436f676de63ee2b230582c83a357cf03\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/OPv1Order.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @title Oasis Protocol v1 Order Library\\n/// @author Oasis Developers\\nlibrary OPv1Order {\\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\\n    /// all order parameters that are signed for submitting to GP.\\n    struct Data {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n        bytes32 sellTokenBalance;\\n        bytes32 buyTokenBalance;\\n    }\\n\\n    /// @dev The order EIP-712 type hash for the [`OPv1Order.Data`] struct.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\n    ///     \\\"Order(\\\" +\\n    ///         \\\"address sellToken,\\\" +\\n    ///         \\\"address buyToken,\\\" +\\n    ///         \\\"address receiver,\\\" +\\n    ///         \\\"uint256 sellAmount,\\\" +\\n    ///         \\\"uint256 buyAmount,\\\" +\\n    ///         \\\"uint32 validTo,\\\" +\\n    ///         \\\"bytes32 appData,\\\" +\\n    ///         \\\"uint256 feeAmount,\\\" +\\n    ///         \\\"string kind,\\\" +\\n    ///         \\\"bool partiallyFillable,\\\" +\\n    ///         \\\"string sellTokenBalance,\\\" +\\n    ///         \\\"string buyTokenBalance\\\" +\\n    ///     \\\")\\\"\\n    /// )\\n    /// ```\\n    bytes32 internal constant TYPE_HASH =\\n        hex\\\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\\\";\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"sell\\\")\\n    /// ```\\n    bytes32 internal constant KIND_SELL =\\n        hex\\\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\\\";\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"buy\\\")\\n    /// ```\\n    bytes32 internal constant KIND_BUY =\\n        hex\\\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\\\";\\n\\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\\n    /// computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"erc20\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_ERC20 =\\n        hex\\\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault external\\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\\n    /// order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"external\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_EXTERNAL =\\n        hex\\\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\\\";\\n\\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\\n    /// balances for computing the order struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"internal\\\")\\n    /// ```\\n    bytes32 internal constant BALANCE_INTERNAL =\\n        hex\\\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\\\";\\n\\n    /// @dev Marker address used to indicate that the receiver of the trade\\n    /// proceeds should the owner of the order.\\n    ///\\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\\n    /// to be the most common case.\\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\\n\\n    /// @dev The byte length of an order unique identifier.\\n    uint256 internal constant UID_LENGTH = 56;\\n\\n    /// @dev Returns the actual receiver for an order. This function checks\\n    /// whether or not the [`receiver`] field uses the marker value to indicate\\n    /// it is the same as the order owner.\\n    ///\\n    /// @return receiver The actual receiver of trade proceeds.\\n    function actualReceiver(\\n        Data memory order,\\n        address owner\\n    ) internal pure returns (address receiver) {\\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\\n            receiver = owner;\\n        } else {\\n            receiver = order.receiver;\\n        }\\n    }\\n\\n    /// @dev Return the EIP-712 signing hash for the specified order.\\n    ///\\n    /// @param order The order to compute the EIP-712 signing hash for.\\n    /// @param domainSeparator The EIP-712 domain separator to use.\\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\\n    function hash(\\n        Data memory order,\\n        bytes32 domainSeparator\\n    ) internal pure returns (bytes32 orderDigest) {\\n        bytes32 structHash;\\n\\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\\n        // in the EIP proposal, noting that the order struct has 12 fields, and\\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let dataStart := sub(order, 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, TYPE_HASH)\\n            structHash := keccak256(dataStart, 416)\\n            mstore(dataStart, temp)\\n        }\\n\\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\\n        // hash using scratch memory past the free memory pointer. The signing\\n        // hash is computed from `\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash`.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\\n            mstore(add(freeMemoryPointer, 34), structHash)\\n            orderDigest := keccak256(freeMemoryPointer, 66)\\n        }\\n    }\\n\\n    /// @dev Packs order UID parameters into the specified memory location. The\\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\\n    /// it allows re-using the memory for packing the order UID.\\n    ///\\n    /// This function reverts if the order UID buffer is not the correct size.\\n    ///\\n    /// @param orderUid The buffer pack the order UID parameters into.\\n    /// @param orderDigest The EIP-712 struct digest derived from the order\\n    /// parameters.\\n    /// @param owner The address of the user who owns this order.\\n    /// @param validTo The epoch time at which the order will stop being valid.\\n    function packOrderUidParams(\\n        bytes memory orderUid,\\n        bytes32 orderDigest,\\n        address owner,\\n        uint32 validTo\\n    ) internal pure {\\n        require(orderUid.length == UID_LENGTH, \\\"OPv1: uid buffer overflow\\\");\\n\\n        // NOTE: Write the order UID to the allocated memory buffer. The order\\n        // parameters are written to memory in **reverse order** as memory\\n        // operations write 32-bytes at a time and we want to use a packed\\n        // encoding. This means, for example, that after writing the value of\\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\\n        // only 20 bytes and `20:32` should be `0`s:\\n        //\\n        //        |           1111111111222222222233333333334444444444555555\\n        //   byte | 01234567890123456789012345678901234567890123456789012345\\n        // -------+---------------------------------------------------------\\n        //  field | [.........orderDigest..........][......owner.......][vT]\\n        // -------+---------------------------------------------------------\\n        // mstore |                         [000000000000000000000000000.vT]\\n        //        |                     [00000000000.......owner.......]\\n        //        | [.........orderDigest..........]\\n        //\\n        // Additionally, since Solidity `bytes memory` are length prefixed,\\n        // 32 needs to be added to all the offsets.\\n        //\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(add(orderUid, 56), validTo)\\n            mstore(add(orderUid, 52), owner)\\n            mstore(add(orderUid, 32), orderDigest)\\n        }\\n    }\\n\\n    /// @dev Extracts specific order information from the standardized unique\\n    /// order id of the protocol.\\n    ///\\n    /// @param orderUid The unique identifier used to represent an order in\\n    /// the protocol. This uid is the packed concatenation of the order digest,\\n    /// the validTo order parameter and the address of the user who created the\\n    /// order. It is used by the user to interface with the contract directly,\\n    /// and not by calls that are triggered by the solvers.\\n    /// @return orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the user who owns this order.\\n    /// @return validTo The epoch time at which the order will stop being valid.\\n    function extractOrderUidParams(\\n        bytes calldata orderUid\\n    )\\n        internal\\n        pure\\n        returns (bytes32 orderDigest, address owner, uint32 validTo)\\n    {\\n        require(orderUid.length == UID_LENGTH, \\\"OPv1: invalid uid\\\");\\n\\n        // Use assembly to efficiently decode packed calldata.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            orderDigest := calldataload(orderUid.offset)\\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x84a4460e3d8813c4bcf7bd3dfdf37fbb940b40751af07b408f9630ada464a7e9\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/OPv1SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @title Oasis Protocol v1 Safe ERC20 Transfer Library\\n/// @author Oasis Developers\\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\\nlibrary OPv1SafeERC20 {\\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\\n    /// also when the token returns `false`.\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        bytes4 selector_ = token.transfer.selector;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            )\\n            mstore(add(freeMemoryPointer, 36), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        require(getLastTransferResult(token), \\\"OPv1: failed transfer\\\");\\n    }\\n\\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\\n    /// reverts also when the token returns `false`.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        bytes4 selector_ = token.transferFrom.selector;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\\n            )\\n            mstore(\\n                add(freeMemoryPointer, 36),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            )\\n            mstore(add(freeMemoryPointer, 68), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        require(getLastTransferResult(token), \\\"OPv1: failed transferFrom\\\");\\n    }\\n\\n    /// @dev Verifies that the last return was a successful `transfer*` call.\\n    /// This is done by checking that the return data is either empty, or\\n    /// is a valid ABI encoded boolean.\\n    function getLastTransferResult(\\n        IERC20 token\\n    ) private view returns (bool success) {\\n        // NOTE: Inspecting previous return data requires assembly. Note that\\n        // we write the return data to memory 0 in the case where the return\\n        // data size is 32, this is OK since the first 64 bytes of memory are\\n        // reserved by Solidy as a scratch space that can be used within\\n        // assembly blocks.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            /// @dev Revert with an ABI encoded Solidity error with a message\\n            /// that fits into 32-bytes.\\n            ///\\n            /// An ABI encoded Solidity error has the following memory layout:\\n            ///\\n            /// ------------+----------------------------------\\n            ///  byte range | value\\n            /// ------------+----------------------------------\\n            ///  0x00..0x04 |        selector(\\\"Error(string)\\\")\\n            ///  0x04..0x24 |      string offset (always 0x20)\\n            ///  0x24..0x44 |                    string length\\n            ///  0x44..0x64 | string value, padded to 32-bytes\\n            function revertWithMessage(length, message) {\\n                mstore(0x00, \\\"\\\\x08\\\\xc3\\\\x79\\\\xa0\\\")\\n                mstore(0x04, 0x20)\\n                mstore(0x24, length)\\n                mstore(0x44, message)\\n                revert(0x00, 0x64)\\n            }\\n\\n            switch returndatasize()\\n            // Non-standard ERC20 transfer without return.\\n            case 0 {\\n                // NOTE: When the return data size is 0, verify that there\\n                // is code at the address. This is done in order to maintain\\n                // compatibility with Solidity calling conventions.\\n                // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\\n                if iszero(extcodesize(token)) {\\n                    revertWithMessage(20, \\\"OPv1: not a contract\\\")\\n                }\\n\\n                success := 1\\n            }\\n            // Standard ERC20 transfer returning boolean success value.\\n            case 32 {\\n                returndatacopy(0, 0, returndatasize())\\n\\n                // NOTE: For ABI encoding v1, any non-zero value is accepted\\n                // as `true` for a boolean. In order to stay compatible with\\n                // OpenZeppelin's `SafeERC20` library which is known to work\\n                // with the existing ERC20 implementation we care about,\\n                // make sure we return success for any non-zero return value\\n                // from the `transfer*` call.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            default {\\n                revertWithMessage(31, \\\"OPv1: malformed transfer result\\\")\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f20fb0a187fd757433ca750c3f7def36cee0dd95e2780e17ad703003a38e229\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/OPv1Trade.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../mixins/OPv1Signing.sol\\\";\\nimport \\\"./OPv1Order.sol\\\";\\n\\n/// @title Oasis Protocol v1 Trade Library.\\n/// @author Oasis Developers\\nlibrary OPv1Trade {\\n    using OPv1Order for OPv1Order.Data;\\n    using OPv1Order for bytes;\\n\\n    /// @dev A struct representing a trade to be executed as part a batch\\n    /// settlement.\\n    struct Data {\\n        uint256 sellTokenIndex;\\n        uint256 buyTokenIndex;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        uint256 flags;\\n        uint256 executedAmount;\\n        bytes signature;\\n    }\\n\\n    /// @dev Extracts the order data and signing scheme for the specified trade.\\n    ///\\n    /// @param trade The trade.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the trade parameters map to tokens in this array.\\n    /// @param order The memory location to extract the order data to.\\n    function extractOrder(\\n        Data calldata trade,\\n        IERC20[] calldata tokens,\\n        OPv1Order.Data memory order\\n    ) internal pure returns (OPv1Signing.Scheme signingScheme) {\\n        order.sellToken = tokens[trade.sellTokenIndex];\\n        order.buyToken = tokens[trade.buyTokenIndex];\\n        order.receiver = trade.receiver;\\n        order.sellAmount = trade.sellAmount;\\n        order.buyAmount = trade.buyAmount;\\n        order.validTo = trade.validTo;\\n        order.appData = trade.appData;\\n        order.feeAmount = trade.feeAmount;\\n        (\\n            order.kind,\\n            order.partiallyFillable,\\n            order.sellTokenBalance,\\n            order.buyTokenBalance,\\n            signingScheme\\n        ) = extractFlags(trade.flags);\\n    }\\n\\n    /// @dev Decodes trade flags.\\n    ///\\n    /// Trade flags are used to tightly encode information on how to decode\\n    /// an order. Examples that directly affect the structure of an order are\\n    /// the kind of order (either a sell or a buy order) as well as whether the\\n    /// order is partially fillable or if it is a \\\"fill-or-kill\\\" order. It also\\n    /// encodes the signature scheme used to validate the order. As the most\\n    /// likely values are fill-or-kill sell orders by an externally owned\\n    /// account, the flags are chosen such that `0x00` represents this kind of\\n    /// order. The flags byte uses the following format:\\n    ///\\n    /// ```\\n    /// bit | 31 ...   | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\\n    /// ----+----------+-------+---+-------+---+---+\\n    ///     | reserved | *   * | * | *   * | * | * |\\n    ///                  |   |   |   |   |   |   |\\n    ///                  |   |   |   |   |   |   +---- order kind bit, 0 for a sell order\\n    ///                  |   |   |   |   |   |         and 1 for a buy order\\n    ///                  |   |   |   |   |   |\\n    ///                  |   |   |   |   |   +-------- order fill bit, 0 for fill-or-kill\\n    ///                  |   |   |   |   |             and 1 for a partially fillable order\\n    ///                  |   |   |   |   |\\n    ///                  |   |   |   +---+------------ use internal sell token balance bit:\\n    ///                  |   |   |                     0x: ERC20 token balance\\n    ///                  |   |   |                     10: external Balancer Vault balance\\n    ///                  |   |   |                     11: internal Balancer Vault balance\\n    ///                  |   |   |\\n    ///                  |   |   +-------------------- use buy token balance bit\\n    ///                  |   |                         0: ERC20 token balance\\n    ///                  |   |                         1: internal Balancer Vault balance\\n    ///                  |   |\\n    ///                  +---+------------------------ signature scheme bits:\\n    ///                                                00: EIP-712\\n    ///                                                01: eth_sign\\n    ///                                                10: EIP-1271\\n    ///                                                11: pre_sign\\n    /// ```\\n    function extractFlags(\\n        uint256 flags\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 kind,\\n            bool partiallyFillable,\\n            bytes32 sellTokenBalance,\\n            bytes32 buyTokenBalance,\\n            OPv1Signing.Scheme signingScheme\\n        )\\n    {\\n        if (flags & 0x01 == 0) {\\n            kind = OPv1Order.KIND_SELL;\\n        } else {\\n            kind = OPv1Order.KIND_BUY;\\n        }\\n        partiallyFillable = flags & 0x02 != 0;\\n        if (flags & 0x08 == 0) {\\n            sellTokenBalance = OPv1Order.BALANCE_ERC20;\\n        } else if (flags & 0x04 == 0) {\\n            sellTokenBalance = OPv1Order.BALANCE_EXTERNAL;\\n        } else {\\n            sellTokenBalance = OPv1Order.BALANCE_INTERNAL;\\n        }\\n        if (flags & 0x10 == 0) {\\n            buyTokenBalance = OPv1Order.BALANCE_ERC20;\\n        } else {\\n            buyTokenBalance = OPv1Order.BALANCE_INTERNAL;\\n        }\\n\\n        // NOTE: Take advantage of the fact that Solidity will revert if the\\n        // following expression does not produce a valid enum value. This means\\n        // we check here that the leading reserved bits must be 0.\\n        signingScheme = OPv1Signing.Scheme(flags >> 5);\\n    }\\n}\\n\",\"keccak256\":\"0x99f56e0369e93e733b3e1f38208036da0b21c69088dcb63bc804e89313917f7d\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/OPv1Transfer.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\npragma abicoder v2;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IVault.sol\\\";\\nimport \\\"./OPv1Order.sol\\\";\\nimport \\\"./OPv1SafeERC20.sol\\\";\\n\\n/// @title Oasis Protocol v1 Transfers\\n/// @author Oasis Developers\\nlibrary OPv1Transfer {\\n    using OPv1SafeERC20 for IERC20;\\n\\n    /// @dev Transfer data.\\n    struct Data {\\n        address account;\\n        IERC20 token;\\n        uint256 amount;\\n        bytes32 balance;\\n    }\\n\\n    /// @dev Ether marker address used to indicate an Ether transfer.\\n    address internal constant BUY_ETH_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @dev Execute the specified transfer from the specified account to a\\n    /// recipient. The recipient will either receive internal Vault balances or\\n    /// ERC20 token balances depending on whether the account is using internal\\n    /// balances or not.\\n    ///\\n    /// This method is used for transferring fees to the settlement contract\\n    /// when settling a single order directly with Balancer.\\n    ///\\n    /// Note that this method is subtly different from `transferFromAccounts`\\n    /// with a single transfer with respect to how it deals with internal\\n    /// balances. Specifically, this method will perform an **internal balance\\n    /// transfer to the settlement contract instead of a withdrawal to the\\n    /// external balance of the settlement contract** for trades that specify\\n    /// trading with internal balances. This is done as a gas optimization in\\n    /// the single order \\\"fast-path\\\".\\n    ///\\n    /// @param vault The Balancer vault to use.\\n    /// @param transfer The transfer to perform specifying the sender account.\\n    /// @param recipient The recipient for the transfer.\\n    function fastTransferFromAccount(\\n        IVault vault,\\n        Data calldata transfer,\\n        address recipient\\n    ) internal {\\n        require(\\n            address(transfer.token) != BUY_ETH_ADDRESS,\\n            \\\"OPv1: cannot transfer native ETH\\\"\\n        );\\n\\n        if (transfer.balance == OPv1Order.BALANCE_ERC20) {\\n            transfer.token.safeTransferFrom(\\n                transfer.account,\\n                recipient,\\n                transfer.amount\\n            );\\n        } else {\\n            IVault.UserBalanceOp[]\\n                memory balanceOps = new IVault.UserBalanceOp[](1);\\n\\n            IVault.UserBalanceOp memory balanceOp = balanceOps[0];\\n            balanceOp.kind = transfer.balance == OPv1Order.BALANCE_EXTERNAL\\n                ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL\\n                : IVault.UserBalanceOpKind.TRANSFER_INTERNAL;\\n            balanceOp.asset = transfer.token;\\n            balanceOp.amount = transfer.amount;\\n            balanceOp.sender = transfer.account;\\n            balanceOp.recipient = payable(recipient);\\n\\n            vault.manageUserBalance(balanceOps);\\n        }\\n    }\\n\\n    /// @dev Execute the specified transfers from the specified accounts to a\\n    /// single recipient. The recipient will receive all transfers as ERC20\\n    /// token balances, regardless of whether or not the accounts are using\\n    /// internal Vault balances.\\n    ///\\n    /// This method is used for accumulating user balances into the settlement\\n    /// contract.\\n    ///\\n    /// @param vault The Balancer vault to use.\\n    /// @param transfers The batched transfers to perform specifying the\\n    /// sender accounts.\\n    /// @param recipient The single recipient for all the transfers.\\n    function transferFromAccounts(\\n        IVault vault,\\n        Data[] calldata transfers,\\n        address recipient\\n    ) internal {\\n        // NOTE: Allocate buffer of Vault balance operations large enough to\\n        // hold all OP transfers. This is done to avoid re-allocations (which\\n        // are gas inefficient) while still allowing all transfers to be batched\\n        // into a single Vault call.\\n        IVault.UserBalanceOp[] memory balanceOps = new IVault.UserBalanceOp[](\\n            transfers.length\\n        );\\n        uint256 balanceOpCount = 0;\\n\\n        for (uint256 i = 0; i < transfers.length; i++) {\\n            Data calldata transfer = transfers[i];\\n            require(\\n                address(transfer.token) != BUY_ETH_ADDRESS,\\n                \\\"OPv1: cannot transfer native ETH\\\"\\n            );\\n\\n            if (transfer.balance == OPv1Order.BALANCE_ERC20) {\\n                transfer.token.safeTransferFrom(\\n                    transfer.account,\\n                    recipient,\\n                    transfer.amount\\n                );\\n            } else {\\n                IVault.UserBalanceOp memory balanceOp = balanceOps[\\n                    balanceOpCount++\\n                ];\\n                balanceOp.kind = transfer.balance == OPv1Order.BALANCE_EXTERNAL\\n                    ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL\\n                    : IVault.UserBalanceOpKind.WITHDRAW_INTERNAL;\\n                balanceOp.asset = transfer.token;\\n                balanceOp.amount = transfer.amount;\\n                balanceOp.sender = transfer.account;\\n                balanceOp.recipient = payable(recipient);\\n            }\\n        }\\n\\n        if (balanceOpCount > 0) {\\n            truncateBalanceOpsArray(balanceOps, balanceOpCount);\\n            vault.manageUserBalance(balanceOps);\\n        }\\n    }\\n\\n    /// @dev Execute the specified transfers to their respective accounts.\\n    ///\\n    /// This method is used for paying out trade proceeds from the settlement\\n    /// contract.\\n    ///\\n    /// @param vault The Balancer vault to use.\\n    /// @param transfers The batched transfers to perform.\\n    function transferToAccounts(\\n        IVault vault,\\n        Data[] memory transfers\\n    ) internal {\\n        IVault.UserBalanceOp[] memory balanceOps = new IVault.UserBalanceOp[](\\n            transfers.length\\n        );\\n        uint256 balanceOpCount = 0;\\n\\n        for (uint256 i = 0; i < transfers.length; i++) {\\n            Data memory transfer = transfers[i];\\n\\n            if (address(transfer.token) == BUY_ETH_ADDRESS) {\\n                require(\\n                    transfer.balance != OPv1Order.BALANCE_INTERNAL,\\n                    \\\"OPv1: unsupported internal ETH\\\"\\n                );\\n                payable(transfer.account).transfer(transfer.amount);\\n            } else if (transfer.balance == OPv1Order.BALANCE_ERC20) {\\n                transfer.token.safeTransfer(transfer.account, transfer.amount);\\n            } else {\\n                IVault.UserBalanceOp memory balanceOp = balanceOps[\\n                    balanceOpCount++\\n                ];\\n                balanceOp.kind = IVault.UserBalanceOpKind.DEPOSIT_INTERNAL;\\n                balanceOp.asset = transfer.token;\\n                balanceOp.amount = transfer.amount;\\n                balanceOp.sender = address(this);\\n                balanceOp.recipient = payable(transfer.account);\\n            }\\n        }\\n\\n        if (balanceOpCount > 0) {\\n            truncateBalanceOpsArray(balanceOps, balanceOpCount);\\n            vault.manageUserBalance(balanceOps);\\n        }\\n    }\\n\\n    /// @dev Truncate a Vault balance operation array to its actual size.\\n    ///\\n    /// This method **does not** check whether or not the new length is valid,\\n    /// and specifying a size that is larger than the array's actual length is\\n    /// undefined behaviour.\\n    ///\\n    /// @param balanceOps The memory array of balance operations to truncate.\\n    /// @param newLength The new length to set.\\n    function truncateBalanceOpsArray(\\n        IVault.UserBalanceOp[] memory balanceOps,\\n        uint256 newLength\\n    ) private pure {\\n        // NOTE: Truncate the vault transfers array to the specified length.\\n        // This is done by setting the array's length which occupies the first\\n        // word in memory pointed to by the `balanceOps` memory variable.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(balanceOps, newLength)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x21fd8caeb8c81e08cf3fc16817d0b4d013921d96cd4d2231dbff2a8dd5a3d053\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin contracts with minor modifications:\\n// - Modified Solidity version\\n// - Formatted code\\n// - Shortened revert messages\\n// - Removed unused methods\\n// - Convert to `type(*).*` notation\\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/SafeCast.sol>\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: not positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(\\n            value <= uint256(type(int256).max),\\n            \\\"SafeCast: int256 overflow\\\"\\n        );\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x1080c5a0503fb51c76806e85b474a795f4e5e401d78cf9ce89f9bf5e921c01f9\",\"license\":\"MIT\"},\"src/contracts/libraries/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin contracts with minor modifications:\\n// - Modified Solidity version\\n// - Formatted code\\n// - Shortened some revert messages\\n// - Removed unused methods\\n// - Added `ceilDiv` method\\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/math/SafeMath.sol>\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: mul overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by 0\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling integer division of two unsigned integers,\\n     * reverting on division by zero. The result is rounded towards up the\\n     * nearest integer, instead of truncating the fractional part.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     * - The sum of the dividend and divisor cannot overflow.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: ceiling division by 0\\\");\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0x035ecce1066e2cbb1420bda9f1347fc6b95dbd67c370af04d3b2596aae8721cc\",\"license\":\"MIT\"},\"src/contracts/mixins/OPv1Signing.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../interfaces/OPv1EIP1271.sol\\\";\\nimport \\\"../libraries/OPv1Order.sol\\\";\\nimport \\\"../libraries/OPv1Trade.sol\\\";\\n\\n/// @title Oasis Protocol v1 Signing Library.\\n/// @author Oasis Developers\\nabstract contract OPv1Signing {\\n    using OPv1Order for OPv1Order.Data;\\n    using OPv1Order for bytes;\\n\\n    /// @dev Recovered trade data containing the extracted order and the\\n    /// recovered owner address.\\n    struct RecoveredOrder {\\n        OPv1Order.Data data;\\n        bytes uid;\\n        address owner;\\n        address receiver;\\n    }\\n\\n    /// @dev Signing scheme used for recovery.\\n    enum Scheme {\\n        Eip712,\\n        EthSign,\\n        Eip1271,\\n        PreSign\\n    }\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 private constant DOMAIN_TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 private constant DOMAIN_NAME = keccak256(\\\"Gnosis Protocol\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 private constant DOMAIN_VERSION = keccak256(\\\"v2\\\");\\n\\n    /// @dev Marker value indicating an order is pre-signed.\\n    uint256 private constant PRE_SIGNED =\\n        uint256(keccak256(\\\"OPv1Signing.Scheme.PreSign\\\"));\\n\\n    /// @dev The domain separator used for signing orders that gets mixed in\\n    /// making signatures for different domains incompatible. This domain\\n    /// separator is computed following the EIP-712 standard and has replay\\n    /// protection mixed in so that signed orders are only valid for specific\\n    /// OPv1 contracts.\\n    bytes32 public immutable domainSeparator;\\n\\n    /// @dev Storage indicating whether or not an order has been signed by a\\n    /// particular address.\\n    mapping(bytes => uint256) public preSignature;\\n\\n    /// @dev Event that is emitted when an account either pre-signs an order or\\n    /// revokes an existing pre-signature.\\n    event PreSignature(address indexed owner, bytes orderUid, bool signed);\\n\\n    constructor() {\\n        // NOTE: Currently, the only way to get the chain ID in solidity is\\n        // using assembly.\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Sets a presignature for the specified order UID.\\n    ///\\n    /// @param orderUid The unique identifier of the order to pre-sign.\\n    /// @param signed True to set the order as tradable with pre-sign, false to\\n    /// false to unset it.\\n    function setPreSignature(bytes calldata orderUid, bool signed) external {\\n        (, address owner, ) = orderUid.extractOrderUidParams();\\n        require(owner == msg.sender, \\\"OPv1: cannot presign order\\\");\\n        if (signed) {\\n            preSignature[orderUid] = PRE_SIGNED;\\n        } else {\\n            preSignature[orderUid] = 0;\\n        }\\n        emit PreSignature(owner, orderUid, signed);\\n    }\\n\\n    /// @dev Returns an empty recovered order with a pre-allocated buffer for\\n    /// packing the unique identifier.\\n    ///\\n    /// @return recoveredOrder The empty recovered order data.\\n    function allocateRecoveredOrder()\\n        internal\\n        pure\\n        returns (RecoveredOrder memory recoveredOrder)\\n    {\\n        recoveredOrder.uid = new bytes(OPv1Order.UID_LENGTH);\\n    }\\n\\n    /// @dev Extracts order data and recovers the signer from the specified\\n    /// trade.\\n    ///\\n    /// @param recoveredOrder Memory location used for writing the recovered order data.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the trade parameters map to tokens in this array.\\n    /// @param trade The trade data to recover the order data from.\\n    function recoverOrderFromTrade(\\n        RecoveredOrder memory recoveredOrder,\\n        IERC20[] calldata tokens,\\n        OPv1Trade.Data calldata trade\\n    ) internal view {\\n        OPv1Order.Data memory order = recoveredOrder.data;\\n\\n        Scheme signingScheme = OPv1Trade.extractOrder(trade, tokens, order);\\n        (bytes32 orderDigest, address owner) = recoverOrderSigner(\\n            order,\\n            signingScheme,\\n            trade.signature\\n        );\\n\\n        recoveredOrder.uid.packOrderUidParams(\\n            orderDigest,\\n            owner,\\n            order.validTo\\n        );\\n        recoveredOrder.owner = owner;\\n        recoveredOrder.receiver = order.actualReceiver(owner);\\n    }\\n\\n    /// @dev The length of any signature from an externally owned account.\\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\\n\\n    /// @dev Recovers an order's signer from the specified order and signature.\\n    ///\\n    /// @param order The order to recover a signature for.\\n    /// @param signingScheme The signing scheme.\\n    /// @param signature The signature bytes.\\n    /// @return orderDigest The computed order hash.\\n    /// @return owner The recovered address from the specified signature.\\n    function recoverOrderSigner(\\n        OPv1Order.Data memory order,\\n        Scheme signingScheme,\\n        bytes calldata signature\\n    ) internal view returns (bytes32 orderDigest, address owner) {\\n        orderDigest = order.hash(domainSeparator);\\n        if (signingScheme == Scheme.Eip712) {\\n            owner = recoverEip712Signer(orderDigest, signature);\\n        } else if (signingScheme == Scheme.EthSign) {\\n            owner = recoverEthsignSigner(orderDigest, signature);\\n        } else if (signingScheme == Scheme.Eip1271) {\\n            owner = recoverEip1271Signer(orderDigest, signature);\\n        } else {\\n            // signingScheme == Scheme.PreSign\\n            owner = recoverPreSigner(orderDigest, signature, order.validTo);\\n        }\\n    }\\n\\n    /// @dev Perform an ECDSA recover for the specified message and calldata\\n    /// signature.\\n    ///\\n    /// The signature is encoded by tighyly packing the following struct:\\n    /// ```\\n    /// struct EncodedSignature {\\n    ///     bytes32 r;\\n    ///     bytes32 s;\\n    ///     uint8 v;\\n    /// }\\n    /// ```\\n    ///\\n    /// @param message The signed message.\\n    /// @param encodedSignature The encoded signature.\\n    function ecdsaRecover(\\n        bytes32 message,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address signer) {\\n        require(\\n            encodedSignature.length == ECDSA_SIGNATURE_LENGTH,\\n            \\\"OPv1: malformed ecdsa signature\\\"\\n        );\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // NOTE: Use assembly to efficiently decode signature data.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // r = uint256(encodedSignature[0:32])\\n            r := calldataload(encodedSignature.offset)\\n            // s = uint256(encodedSignature[32:64])\\n            s := calldataload(add(encodedSignature.offset, 32))\\n            // v = uint8(encodedSignature[64])\\n            v := shr(248, calldataload(add(encodedSignature.offset, 64)))\\n        }\\n\\n        signer = ecrecover(message, v, r, s);\\n        require(signer != address(0), \\\"OPv1: invalid ecdsa signature\\\");\\n    }\\n\\n    /// @dev Decodes signature bytes originating from an EIP-712-encoded\\n    /// signature.\\n    ///\\n    /// EIP-712 signs typed data. The specifications are described in the\\n    /// related EIP (<https://eips.ethereum.org/EIPS/eip-712>).\\n    ///\\n    /// EIP-712 signatures are encoded as standard ECDSA signatures as described\\n    /// in the corresponding decoding function [`ecdsaRecover`].\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature Calldata pointing to tightly packed signature\\n    /// bytes.\\n    /// @return owner The address of the signer.\\n    function recoverEip712Signer(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address owner) {\\n        owner = ecdsaRecover(orderDigest, encodedSignature);\\n    }\\n\\n    /// @dev Decodes signature bytes originating from the output of the eth_sign\\n    /// RPC call.\\n    ///\\n    /// The specifications are described in the Ethereum documentation\\n    /// (<https://eth.wiki/json-rpc/API#eth_sign>).\\n    ///\\n    /// eth_sign signatures are encoded as standard ECDSA signatures as\\n    /// described in the corresponding decoding function\\n    /// [`ecdsaRecover`].\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature Calldata pointing to tightly packed signature\\n    /// bytes.\\n    /// @return owner The address of the signer.\\n    function recoverEthsignSigner(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal pure returns (address owner) {\\n        // The signed message is encoded as:\\n        // `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" || length || data`, where\\n        // the length is a constant (32 bytes) and the data is defined as:\\n        // `orderDigest`.\\n        bytes32 ethsignDigest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", orderDigest)\\n        );\\n\\n        owner = ecdsaRecover(ethsignDigest, encodedSignature);\\n    }\\n\\n    /// @dev Verifies the input calldata as an EIP-1271 contract signature and\\n    /// returns the address of the signer.\\n    ///\\n    /// The encoded signature tightly packs the following struct:\\n    ///\\n    /// ```\\n    /// struct EncodedEip1271Signature {\\n    ///     address owner;\\n    ///     bytes signature;\\n    /// }\\n    /// ```\\n    ///\\n    /// This function enforces that the encoded data stores enough bytes to\\n    /// cover the full length of the decoded signature.\\n    ///\\n    /// @param encodedSignature The encoded EIP-1271 signature.\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the signer.\\n    function recoverEip1271Signer(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature\\n    ) internal view returns (address owner) {\\n        // NOTE: Use assembly to read the verifier address from the encoded\\n        // signature bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // owner = address(encodedSignature[0:20])\\n            owner := shr(96, calldataload(encodedSignature.offset))\\n        }\\n\\n        // NOTE: Configure prettier to ignore the following line as it causes\\n        // a panic in the Solidity plugin.\\n        // prettier-ignore\\n        bytes calldata signature = encodedSignature[20:];\\n\\n        require(\\n            EIP1271Verifier(owner).isValidSignature(orderDigest, signature) ==\\n                OPv1EIP1271.MAGICVALUE,\\n            \\\"OPv1: invalid eip1271 signature\\\"\\n        );\\n    }\\n\\n    /// @dev Verifies the order has been pre-signed. The signature is the\\n    /// address of the signer of the order.\\n    ///\\n    /// @param orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @param encodedSignature The pre-sign signature reprenting the order UID.\\n    /// @param validTo The order expiry timestamp.\\n    /// @return owner The address of the signer.\\n    function recoverPreSigner(\\n        bytes32 orderDigest,\\n        bytes calldata encodedSignature,\\n        uint32 validTo\\n    ) internal view returns (address owner) {\\n        require(encodedSignature.length == 20, \\\"OPv1: malformed presignature\\\");\\n        // NOTE: Use assembly to read the owner address from the encoded\\n        // signature bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // owner = address(encodedSignature[0:20])\\n            owner := shr(96, calldataload(encodedSignature.offset))\\n        }\\n\\n        bytes memory orderUid = new bytes(OPv1Order.UID_LENGTH);\\n        orderUid.packOrderUidParams(orderDigest, owner, validTo);\\n\\n        require(\\n            preSignature[orderUid] == PRE_SIGNED,\\n            \\\"OPv1: order not presigned\\\"\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xab93f1ebaa2e36549025040a386a33e9685284485252a53cdbe5de0fe6d0326d\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/mixins/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin contracts with minor modifications:\\n// - Modified Solidity version\\n// - Formatted code\\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/ReentrancyGuard.sol>\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x35c029266e8cb2e2d522d3e37cc2660bfb433708cf832382c94c8a286160abe5\",\"license\":\"MIT\"},\"src/contracts/mixins/StorageAccessible.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\n\\n// Vendored from Oasis utility contracts with minor modifications:\\n// - Modified Solidity version\\n// - Formatted code\\n// - Added linter directives to ignore low level call and assembly warnings\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title ViewStorageAccessible - Interface on top of StorageAccessible base class to allow simulations from view functions\\ninterface ViewStorageAccessible {\\n    /**\\n     * @dev Same as `simulateDelegatecall` on StorageAccessible. Marked as view so that it can be called from external contracts\\n     * that want to run simulations from within view functions. Will revert if the invoked simulation attempts to change state.\\n     */\\n    function simulateDelegatecall(\\n        address targetContract,\\n        bytes memory calldataPayload\\n    ) external view returns (bytes memory);\\n\\n    /**\\n     * @dev Same as `getStorageAt` on StorageAccessible. This method allows reading aribtrary ranges of storage.\\n     */\\n    function getStorageAt(\\n        uint256 offset,\\n        uint256 length\\n    ) external view returns (bytes memory);\\n}\\n\\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\\ncontract StorageAccessible {\\n    /**\\n     * @dev Reads `length` bytes of storage in the currents contract\\n     * @param offset - the offset in the current contract's storage in words to start reading from\\n     * @param length - the number of words (32 bytes) of data to read\\n     * @return the bytes that were read.\\n     */\\n    function getStorageAt(\\n        uint256 offset,\\n        uint256 length\\n    ) external view returns (bytes memory) {\\n        bytes memory result = new bytes(length * 32);\\n        for (uint256 index = 0; index < length; index++) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let word := sload(add(offset, index))\\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs a delegetecall on a targetContract in the context of self.\\n     * Internally reverts execution to avoid side effects (making it static). Catches revert and returns encoded result as bytes.\\n     * @param targetContract Address of the contract containing the code to execute.\\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\\n     */\\n    function simulateDelegatecall(\\n        address targetContract,\\n        bytes memory calldataPayload\\n    ) public returns (bytes memory response) {\\n        bytes memory innerCall = abi.encodeWithSelector(\\n            this.simulateDelegatecallInternal.selector,\\n            targetContract,\\n            calldataPayload\\n        );\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (, response) = address(this).call(innerCall);\\n        bool innerSuccess = response[response.length - 1] == 0x01;\\n        setLength(response, response.length - 1);\\n        if (innerSuccess) {\\n            return response;\\n        } else {\\n            revertWith(response);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a delegetecall on a targetContract in the context of self.\\n     * Internally reverts execution to avoid side effects (making it static). Returns encoded result as revert message\\n     * concatenated with the success flag of the inner call as a last byte.\\n     * @param targetContract Address of the contract containing the code to execute.\\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\\n     */\\n    function simulateDelegatecallInternal(\\n        address targetContract,\\n        bytes memory calldataPayload\\n    ) external returns (bytes memory response) {\\n        bool success;\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, response) = targetContract.delegatecall(calldataPayload);\\n        revertWith(abi.encodePacked(response, success));\\n    }\\n\\n    function revertWith(bytes memory response) internal pure {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            revert(add(response, 0x20), mload(response))\\n        }\\n    }\\n\\n    function setLength(bytes memory buffer, uint256 length) internal pure {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(buffer, length)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd680803109d5d936c2b24a85886f9ff19b3feb6983223652a303e3443186f18f\",\"license\":\"LGPL-3.0-only\"},\"src/contracts/reader/OPv1TradeSimulator.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.7.6 <0.9.0;\\npragma abicoder v2;\\n\\nimport \\\"../OPv1Settlement.sol\\\";\\n\\n/// @title Oasis Protocol v1 Trade Simulator\\n/// @author Oasis Developers\\ncontract OPv1TradeSimulator {\\n    using OPv1Transfer for IVault;\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n\\n    /// @dev A trade to simulate.\\n    struct Trade {\\n        address owner;\\n        address receiver;\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        bytes32 sellTokenBalance;\\n        bytes32 buyTokenBalance;\\n    }\\n\\n    /// @dev Initial token state used internally for computing balance changes.\\n    struct TokenState {\\n        IERC20 token;\\n        address account;\\n        uint256 initialBalance;\\n    }\\n\\n    /// @dev Account state for tracking individual token states per user.\\n    struct AccountState {\\n        TokenState sellTokenState;\\n        TokenState buyTokenState;\\n    }\\n\\n    /// @dev Simulation context.\\n    struct Context {\\n        uint256 gasCounter;\\n        OPv1Transfer.Data[] inTransfers;\\n        OPv1Transfer.Data[] outTransfers;\\n        AccountState contractAccount;\\n        AccountState ownerAccount;\\n    }\\n\\n    /// @dev Account balance changes included in the results.\\n    struct BalanceDelta {\\n        int256 sellTokenDelta;\\n        int256 buyTokenDelta;\\n    }\\n\\n    /// @dev Simulation result.\\n    struct Result {\\n        uint256 gasUsed;\\n        uint256 executedBuyAmount;\\n        BalanceDelta contractBalance;\\n        BalanceDelta ownerBalance;\\n    }\\n\\n    /// @dev Sentinal value to indicate that the buy amount for the trade's out\\n    /// transfer should use all received buy tokens from the interactions\\n    /// specified for the simulation.\\n    uint256 private constant USE_ALL_RECEIVED_BUY_TOKENS = 0;\\n\\n    /// @dev Simulates a user trade.\\n    ///\\n    /// This method can be used to determine whether or not a token is supported\\n    /// as well as getting a rough estimate on how much gas is required to\\n    /// execute the trade given a set of interactions.\\n    ///\\n    /// One notable difference, is the simulation doesn't actually require an\\n    /// order. This makes using this method inaccurate for predicting gas usage\\n    /// for specific trades. However, seeing as computing trade executions is\\n    /// completely independent of external contracts (i.e. it does not depend on\\n    /// the tokens being traded or the interactions being executed) the gas\\n    /// consumption should be off by a predicatable amount.\\n    ///\\n    /// @param trade The trade to simulate.\\n    /// @param interactions A set of interactions to settle the trade against.\\n    function simulateTrade(\\n        Trade calldata trade,\\n        OPv1Interaction.Data[][3] calldata interactions\\n    ) external returns (Result memory result) {\\n        Context memory context = createContext(trade);\\n        OPv1Settlement self = OPv1Settlement(payable(address(this)));\\n\\n        executeInteractions(interactions[0]);\\n\\n        self.vaultRelayer().transferFromAccounts(context.inTransfers);\\n\\n        executeInteractions(interactions[1]);\\n\\n        updateOutTransferAmount(context);\\n        self.vault().transferToAccounts(context.outTransfers);\\n\\n        executeInteractions(interactions[2]);\\n\\n        finalizeResult(context, result);\\n    }\\n\\n    /// @dev Executes interactions.\\n    function executeInteractions(\\n        OPv1Interaction.Data[] calldata interactions\\n    ) private {\\n        for (uint256 i; i < interactions.length; i++) {\\n            OPv1Interaction.execute(interactions[i]);\\n        }\\n    }\\n\\n    /// @dev Initializes a simulation context in memory for the current trade\\n    /// simulation.\\n    ///\\n    /// This helps organize simulation data and work around \\\"stack too deep\\\"\\n    /// Solidity errors.\\n    function createContext(\\n        Trade calldata trade\\n    ) private view returns (Context memory context) {\\n        context.gasCounter = gasleft();\\n\\n        address actualReceiver = trade.receiver ==\\n            OPv1Order.RECEIVER_SAME_AS_OWNER\\n            ? trade.owner\\n            : trade.receiver;\\n\\n        context.inTransfers = new OPv1Transfer.Data[](1);\\n        {\\n            OPv1Transfer.Data memory inTransfer = context.inTransfers[0];\\n            inTransfer.account = trade.owner;\\n            inTransfer.token = trade.sellToken;\\n            inTransfer.amount = trade.sellAmount;\\n            inTransfer.balance = trade.sellTokenBalance;\\n        }\\n\\n        context.outTransfers = new OPv1Transfer.Data[](1);\\n        {\\n            OPv1Transfer.Data memory outTransfer = context.outTransfers[0];\\n            outTransfer.account = actualReceiver;\\n            outTransfer.token = trade.buyToken;\\n            outTransfer.amount = trade.buyAmount;\\n            outTransfer.balance = trade.buyTokenBalance;\\n        }\\n\\n        {\\n            AccountState memory contractAccount = context.contractAccount;\\n            initializeTokenState(\\n                contractAccount.sellTokenState,\\n                trade.sellToken,\\n                address(this)\\n            );\\n            initializeTokenState(\\n                contractAccount.buyTokenState,\\n                trade.buyToken,\\n                address(this)\\n            );\\n        }\\n\\n        {\\n            AccountState memory ownerAccount = context.ownerAccount;\\n            initializeTokenState(\\n                ownerAccount.sellTokenState,\\n                trade.sellToken,\\n                trade.owner\\n            );\\n            initializeTokenState(\\n                ownerAccount.buyTokenState,\\n                trade.buyToken,\\n                actualReceiver\\n            );\\n        }\\n    }\\n\\n    /// @dev Updates the out transfer token amount to be the exact amount of buy\\n    /// token that has been received so far if the trade simulation was done\\n    /// using a special sentinal values for the buy amount.\\n    function updateOutTransferAmount(Context memory context) private view {\\n        OPv1Transfer.Data memory outTransfer = context.outTransfers[0];\\n        if (outTransfer.amount == USE_ALL_RECEIVED_BUY_TOKENS) {\\n            outTransfer.amount = computeTokenDelta(\\n                context.contractAccount.buyTokenState\\n            ).toUint256();\\n        }\\n    }\\n\\n    /// @dev Computes the simulation result for the given context.\\n    function finalizeResult(\\n        Context memory context,\\n        Result memory result\\n    ) private view {\\n        result.executedBuyAmount = context.outTransfers[0].amount;\\n        computeBalanceDelta(context.contractAccount, result.contractBalance);\\n        computeBalanceDelta(context.ownerAccount, result.ownerBalance);\\n        result.gasUsed = context.gasCounter - gasleft();\\n    }\\n\\n    /// @dev Initializes a token state for the specified token and address\\n    function initializeTokenState(\\n        TokenState memory state,\\n        IERC20 token,\\n        address account\\n    ) private view {\\n        state.token = token;\\n        state.account = account;\\n        state.initialBalance = token.balanceOf(account);\\n    }\\n\\n    /// @dev Computes the account's balance delta for all tokens.\\n    function computeBalanceDelta(\\n        AccountState memory state,\\n        BalanceDelta memory result\\n    ) private view {\\n        result.sellTokenDelta = computeTokenDelta(state.sellTokenState);\\n        result.buyTokenDelta = computeTokenDelta(state.buyTokenState);\\n    }\\n\\n    /// @dev Computes the token balance delta for the specified token state.\\n    function computeTokenDelta(\\n        TokenState memory state\\n    ) private view returns (int256) {\\n        uint256 currentBalance = state.token.balanceOf(state.account);\\n        return currentBalance.toInt256() - state.initialBalance.toInt256();\\n    }\\n}\\n\",\"keccak256\":\"0x1a85d4904e85982cec35a46ae5ca9316dd8ad0dce3a937c1aaae3f6963a65ff0\",\"license\":\"LGPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506111fc806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063924fcc3a14610030575b600080fd5b61004361003e366004610e76565b610059565b6040516100509190611053565b60405180910390f35b610061610d22565b600061006c8461024f565b90503061008b8460005b6020028101906100869190611095565b6104ad565b8073ffffffffffffffffffffffffffffffffffffffff16639b552cc26040518163ffffffff1660e01b815260040160206040518083038186803b1580156100d157600080fd5b505afa1580156100e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101099190610e5a565b73ffffffffffffffffffffffffffffffffffffffff16637d10d11f83602001516040518263ffffffff1660e01b81526004016101459190610f19565b600060405180830381600087803b15801561015f57600080fd5b505af1158015610173573d6000803e3d6000fd5b505050506101878460016003811061007657fe5b610190826104eb565b61023282604001518273ffffffffffffffffffffffffffffffffffffffff1663fbfa77cf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101de57600080fd5b505afa1580156101f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102169190610e5a565b73ffffffffffffffffffffffffffffffffffffffff1690610538565b61023d846002610076565b610247828461081f565b505092915050565b610257610d55565b5a815260008061026d6040850160208601610e37565b73ffffffffffffffffffffffffffffffffffffffff161461029d576102986040840160208501610e37565b6102aa565b6102aa6020840184610e37565b604080516001808252818301909252919250816020015b6102c9610d8a565b8152602001906001900390816102c15750506020830181905280516000919082906102f057fe5b6020026020010151905083600001602081019061030d9190610e37565b73ffffffffffffffffffffffffffffffffffffffff1681526103356060850160408601610e37565b73ffffffffffffffffffffffffffffffffffffffff1660208201526080840135604082015260c084013560609091015260016040519080825280602002602001820160405280156103a057816020015b61038d610d8a565b8152602001906001900390816103855790505b506040830181905280516000919082906103b657fe5b602090810291909101015173ffffffffffffffffffffffffffffffffffffffff8316815290506103ec6080850160608601610e37565b73ffffffffffffffffffffffffffffffffffffffff16602082015260a084013560408083019190915260e085013560609283015283820151805190926104409261043a918801908801610e37565b30610874565b60208101516104599061043a6080870160608801610e37565b5060808201518051610487906104756060870160408801610e37565b6104826020880188610e37565b610874565b60208101516104a6906104a06080870160608801610e37565b84610874565b5050919050565b60005b818110156104e6576104de8383838181106104c757fe5b90506020028101906104d99190611164565b61092e565b6001016104b0565b505050565b600081604001516000815181106104fe57fe5b602002602001015190506000816040015114156105345761052e610529836060015160200151610985565b610a52565b60408201525b5050565b6000815167ffffffffffffffff8111801561055257600080fd5b5060405190808252806020026020018201604052801561058c57816020015b610579610db1565b8152602001906001900390816105715790505b5090506000805b83518110156107835760008482815181106105aa57fe5b6020026020010151905073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee73ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff1614156106b7577f4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce81606001511415610667576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161065e9061101c565b60405180910390fd5b8051604080830151905173ffffffffffffffffffffffffffffffffffffffff9092169181156108fc0291906000818181858888f193505050501580156106b1573d6000803e3d6000fd5b5061077a565b7f5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc981606001511415610716578051604082015160208301516107119273ffffffffffffffffffffffffffffffffffffffff90911691610ac7565b61077a565b600084848060010195508151811061072a57fe5b602090810291909101810151600081528382015173ffffffffffffffffffffffffffffffffffffffff90811692820192909252604080850151908201523060608201528351909116608090910152505b50600101610593565b508015610819576107948282610b9f565b6040517f0e8e3e8400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851690630e8e3e84906107e6908590600401610f96565b600060405180830381600087803b15801561080057600080fd5b505af1158015610814573d6000803e3d6000fd5b505050505b50505050565b816040015160008151811061083057fe5b60200260200101516040015181602001818152505061085782606001518260400151610ba3565b61086982608001518260600151610ba3565b5a9151919091039052565b73ffffffffffffffffffffffffffffffffffffffff80831680855290821660208501526040517f70a082310000000000000000000000000000000000000000000000000000000081526370a08231906108d1908490600401610ef8565b60206040518083038186803b1580156108e957600080fd5b505afa1580156108fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109219190610ed1565b6040909301929092525050565b73ffffffffffffffffffffffffffffffffffffffff813516602082013536600061095b6040860186611101565b9150915060405181838237600080838387895af161097d573d6000803e3d6000fd5b505050505050565b805160208201516040517f70a08231000000000000000000000000000000000000000000000000000000008152600092839273ffffffffffffffffffffffffffffffffffffffff909116916370a08231916109e291600401610ef8565b60206040518083038186803b1580156109fa57600080fd5b505afa158015610a0e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a329190610ed1565b9050610a418360400151610bc7565b610a4a82610bc7565b039392505050565b600080821215610ac357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f53616665436173743a206e6f7420706f73697469766500000000000000000000604482015290519081900360640190fd5b5090565b6040517fa9059cbb0000000000000000000000000000000000000000000000000000000080825273ffffffffffffffffffffffffffffffffffffffff84166004830152602482018390529060008060448382895af1610b2a573d6000803e3d6000fd5b50610b3484610c58565b61081957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4f5076313a206661696c6564207472616e736665720000000000000000000000604482015290519081900360640190fd5b9052565b8151610bae90610985565b81526020820151610bbe90610985565b60209091015250565b60007f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115610ac357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f53616665436173743a20696e74323536206f766572666c6f7700000000000000604482015290519081900360640190fd5b6000610c96565b7f08c379a0000000000000000000000000000000000000000000000000000000006000526020600452806024528160445260646000fd5b3d8015610cd55760208114610d0f57610cd07f4f5076313a206d616c666f726d6564207472616e7366657220726573756c7400601f610c5f565b610d1c565b823b610d0657610d067f4f5076313a206e6f74206120636f6e74726163740000000000000000000000006014610c5f565b60019150610d1c565b3d6000803e600051151591505b50919050565b60405180608001604052806000815260200160008152602001610d43610de1565b8152602001610d50610de1565b905290565b6040518060a00160405280600081526020016060815260200160608152602001610d7d610dfb565b8152602001610d50610dfb565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040805160a081019091528060008152600060208201819052604082018190526060820181905260809091015290565b604051806040016040528060008152602001600081525090565b6040518060400160405280610e0e610e17565b8152602001610d505b604080516060810182526000808252602082018190529181019190915290565b600060208284031215610e48578081fd5b8135610e53816111a1565b9392505050565b600060208284031215610e6b578081fd5b8151610e53816111a1565b600080828403610120811215610e8a578182fd5b61010080821215610e99578283fd5b849350830135905067ffffffffffffffff811115610eb5578182fd5b830160608101851015610ec6578182fd5b809150509250929050565b600060208284031215610ee2578081fd5b5051919050565b80518252602090810151910152565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b602080825282518282018190526000919060409081850190868401855b82811015610f89578151805173ffffffffffffffffffffffffffffffffffffffff908116865287820151168786015285810151868601526060908101519085015260809093019290850190600101610f36565b5091979650505050505050565b602080825282518282018190526000919060409081850190868401855b82811015610f89578151805160048110610fc957fe5b85528087015173ffffffffffffffffffffffffffffffffffffffff908116888701528682015187870152606080830151821690870152608091820151169085015260a09093019290850190600101610fb3565b6020808252601e908201527f4f5076313a20756e737570706f7274656420696e7465726e616c204554480000604082015260600190565b600060c0820190508251825260208301516020830152604083015161107b6040840182610ee9565b50606083015161108e6080840182610ee9565b5092915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126110c9578283fd5b83018035915067ffffffffffffffff8211156110e3578283fd5b60209081019250810236038213156110fa57600080fd5b9250929050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112611135578283fd5b83018035915067ffffffffffffffff82111561114f578283fd5b6020019150368190038213156110fa57600080fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1833603018112611197578182fd5b9190910192915050565b73ffffffffffffffffffffffffffffffffffffffff811681146111c357600080fd5b5056fea26469706673582212206502676b00b59884c1d077303b61d7aff626f2a32099940795c0fe7e92e794d064736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063924fcc3a14610030575b600080fd5b61004361003e366004610e76565b610059565b6040516100509190611053565b60405180910390f35b610061610d22565b600061006c8461024f565b90503061008b8460005b6020028101906100869190611095565b6104ad565b8073ffffffffffffffffffffffffffffffffffffffff16639b552cc26040518163ffffffff1660e01b815260040160206040518083038186803b1580156100d157600080fd5b505afa1580156100e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101099190610e5a565b73ffffffffffffffffffffffffffffffffffffffff16637d10d11f83602001516040518263ffffffff1660e01b81526004016101459190610f19565b600060405180830381600087803b15801561015f57600080fd5b505af1158015610173573d6000803e3d6000fd5b505050506101878460016003811061007657fe5b610190826104eb565b61023282604001518273ffffffffffffffffffffffffffffffffffffffff1663fbfa77cf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101de57600080fd5b505afa1580156101f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102169190610e5a565b73ffffffffffffffffffffffffffffffffffffffff1690610538565b61023d846002610076565b610247828461081f565b505092915050565b610257610d55565b5a815260008061026d6040850160208601610e37565b73ffffffffffffffffffffffffffffffffffffffff161461029d576102986040840160208501610e37565b6102aa565b6102aa6020840184610e37565b604080516001808252818301909252919250816020015b6102c9610d8a565b8152602001906001900390816102c15750506020830181905280516000919082906102f057fe5b6020026020010151905083600001602081019061030d9190610e37565b73ffffffffffffffffffffffffffffffffffffffff1681526103356060850160408601610e37565b73ffffffffffffffffffffffffffffffffffffffff1660208201526080840135604082015260c084013560609091015260016040519080825280602002602001820160405280156103a057816020015b61038d610d8a565b8152602001906001900390816103855790505b506040830181905280516000919082906103b657fe5b602090810291909101015173ffffffffffffffffffffffffffffffffffffffff8316815290506103ec6080850160608601610e37565b73ffffffffffffffffffffffffffffffffffffffff16602082015260a084013560408083019190915260e085013560609283015283820151805190926104409261043a918801908801610e37565b30610874565b60208101516104599061043a6080870160608801610e37565b5060808201518051610487906104756060870160408801610e37565b6104826020880188610e37565b610874565b60208101516104a6906104a06080870160608801610e37565b84610874565b5050919050565b60005b818110156104e6576104de8383838181106104c757fe5b90506020028101906104d99190611164565b61092e565b6001016104b0565b505050565b600081604001516000815181106104fe57fe5b602002602001015190506000816040015114156105345761052e610529836060015160200151610985565b610a52565b60408201525b5050565b6000815167ffffffffffffffff8111801561055257600080fd5b5060405190808252806020026020018201604052801561058c57816020015b610579610db1565b8152602001906001900390816105715790505b5090506000805b83518110156107835760008482815181106105aa57fe5b6020026020010151905073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee73ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff1614156106b7577f4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce81606001511415610667576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161065e9061101c565b60405180910390fd5b8051604080830151905173ffffffffffffffffffffffffffffffffffffffff9092169181156108fc0291906000818181858888f193505050501580156106b1573d6000803e3d6000fd5b5061077a565b7f5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc981606001511415610716578051604082015160208301516107119273ffffffffffffffffffffffffffffffffffffffff90911691610ac7565b61077a565b600084848060010195508151811061072a57fe5b602090810291909101810151600081528382015173ffffffffffffffffffffffffffffffffffffffff90811692820192909252604080850151908201523060608201528351909116608090910152505b50600101610593565b508015610819576107948282610b9f565b6040517f0e8e3e8400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff851690630e8e3e84906107e6908590600401610f96565b600060405180830381600087803b15801561080057600080fd5b505af1158015610814573d6000803e3d6000fd5b505050505b50505050565b816040015160008151811061083057fe5b60200260200101516040015181602001818152505061085782606001518260400151610ba3565b61086982608001518260600151610ba3565b5a9151919091039052565b73ffffffffffffffffffffffffffffffffffffffff80831680855290821660208501526040517f70a082310000000000000000000000000000000000000000000000000000000081526370a08231906108d1908490600401610ef8565b60206040518083038186803b1580156108e957600080fd5b505afa1580156108fd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109219190610ed1565b6040909301929092525050565b73ffffffffffffffffffffffffffffffffffffffff813516602082013536600061095b6040860186611101565b9150915060405181838237600080838387895af161097d573d6000803e3d6000fd5b505050505050565b805160208201516040517f70a08231000000000000000000000000000000000000000000000000000000008152600092839273ffffffffffffffffffffffffffffffffffffffff909116916370a08231916109e291600401610ef8565b60206040518083038186803b1580156109fa57600080fd5b505afa158015610a0e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a329190610ed1565b9050610a418360400151610bc7565b610a4a82610bc7565b039392505050565b600080821215610ac357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f53616665436173743a206e6f7420706f73697469766500000000000000000000604482015290519081900360640190fd5b5090565b6040517fa9059cbb0000000000000000000000000000000000000000000000000000000080825273ffffffffffffffffffffffffffffffffffffffff84166004830152602482018390529060008060448382895af1610b2a573d6000803e3d6000fd5b50610b3484610c58565b61081957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4f5076313a206661696c6564207472616e736665720000000000000000000000604482015290519081900360640190fd5b9052565b8151610bae90610985565b81526020820151610bbe90610985565b60209091015250565b60007f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115610ac357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f53616665436173743a20696e74323536206f766572666c6f7700000000000000604482015290519081900360640190fd5b6000610c96565b7f08c379a0000000000000000000000000000000000000000000000000000000006000526020600452806024528160445260646000fd5b3d8015610cd55760208114610d0f57610cd07f4f5076313a206d616c666f726d6564207472616e7366657220726573756c7400601f610c5f565b610d1c565b823b610d0657610d067f4f5076313a206e6f74206120636f6e74726163740000000000000000000000006014610c5f565b60019150610d1c565b3d6000803e600051151591505b50919050565b60405180608001604052806000815260200160008152602001610d43610de1565b8152602001610d50610de1565b905290565b6040518060a00160405280600081526020016060815260200160608152602001610d7d610dfb565b8152602001610d50610dfb565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040805160a081019091528060008152600060208201819052604082018190526060820181905260809091015290565b604051806040016040528060008152602001600081525090565b6040518060400160405280610e0e610e17565b8152602001610d505b604080516060810182526000808252602082018190529181019190915290565b600060208284031215610e48578081fd5b8135610e53816111a1565b9392505050565b600060208284031215610e6b578081fd5b8151610e53816111a1565b600080828403610120811215610e8a578182fd5b61010080821215610e99578283fd5b849350830135905067ffffffffffffffff811115610eb5578182fd5b830160608101851015610ec6578182fd5b809150509250929050565b600060208284031215610ee2578081fd5b5051919050565b80518252602090810151910152565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b602080825282518282018190526000919060409081850190868401855b82811015610f89578151805173ffffffffffffffffffffffffffffffffffffffff908116865287820151168786015285810151868601526060908101519085015260809093019290850190600101610f36565b5091979650505050505050565b602080825282518282018190526000919060409081850190868401855b82811015610f89578151805160048110610fc957fe5b85528087015173ffffffffffffffffffffffffffffffffffffffff908116888701528682015187870152606080830151821690870152608091820151169085015260a09093019290850190600101610fb3565b6020808252601e908201527f4f5076313a20756e737570706f7274656420696e7465726e616c204554480000604082015260600190565b600060c0820190508251825260208301516020830152604083015161107b6040840182610ee9565b50606083015161108e6080840182610ee9565b5092915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126110c9578283fd5b83018035915067ffffffffffffffff8211156110e3578283fd5b60209081019250810236038213156110fa57600080fd5b9250929050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112611135578283fd5b83018035915067ffffffffffffffff82111561114f578283fd5b6020019150368190038213156110fa57600080fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1833603018112611197578182fd5b9190910192915050565b73ffffffffffffffffffffffffffffffffffffffff811681146111c357600080fd5b5056fea26469706673582212206502676b00b59884c1d077303b61d7aff626f2a32099940795c0fe7e92e794d064736f6c63430007060033",
  "devdoc": {
    "author": "Oasis Developers",
    "kind": "dev",
    "methods": {
      "simulateTrade((address,address,address,address,uint256,uint256,bytes32,bytes32),(address,uint256,bytes)[][3])": {
        "details": "Simulates a user trade. This method can be used to determine whether or not a token is supported as well as getting a rough estimate on how much gas is required to execute the trade given a set of interactions. One notable difference, is the simulation doesn't actually require an order. This makes using this method inaccurate for predicting gas usage for specific trades. However, seeing as computing trade executions is completely independent of external contracts (i.e. it does not depend on the tokens being traded or the interactions being executed) the gas consumption should be off by a predicatable amount.",
        "params": {
          "interactions": "A set of interactions to settle the trade against.",
          "trade": "The trade to simulate."
        }
      }
    },
    "stateVariables": {
      "USE_ALL_RECEIVED_BUY_TOKENS": {
        "details": "Sentinal value to indicate that the buy amount for the trade's out transfer should use all received buy tokens from the interactions specified for the simulation."
      }
    },
    "title": "Oasis Protocol v1 Trade Simulator",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}